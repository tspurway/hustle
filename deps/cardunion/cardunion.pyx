from libc.stdint cimport uint8_t, uint16_t, int32_t, uint64_t, int64_t
from libc.stdlib cimport calloc, free
from libc.string cimport memset, memcpy
from libc.math cimport pow, log, round

from scamurmur3 import murmur3_x64_64


cdef int32_t    SPARSE_FLAG_BIT = 24                    # at the 24 bit where sets the flag of sparse array
cdef size_t     SIZE_OF_SPARSE_FLAGS = sizeof(int32_t)  # length of the header for dumps
cdef int32_t    HASH_LENGTH = 64                        # length of hash
cdef int64_t    HASH_SEED = 9576890767                  # seed of hash function
cdef uint8_t    UINT_ZERO = 0                           # uint8 0
cdef uint64_t   UINT64_ONE = 1                          # uint64 1
cdef uint64_t   BIT_AT_64 = (UINT64_ONE << 63)          # mask as 0x8000000000000000


cdef uint8_t _count_leading_zeros(uint64_t v, uint8_t total_bits):
    """Count the leading zeros of an uint64_t integer from right to left side.
    Defined here because seems Cython doesn't support staticmethod on cdef
    functions.
    """
    cdef uint8_t zeros = 1

    while zeros <= total_bits and not v & BIT_AT_64:
        zeros += 1
        v <<= 1
    return zeros


cdef class Cardunion(object):
    """
    Usage:
        # Feed hll with data then count
        >>> hll = Cardunion(log2m=12)
        >>> for i in range(100000):
                hll.add(str(i))
        >>> hll.count()

        # For serialization
        >>> zipped = hll.dumps()

        # Restore hll by zipped data
        >>> new_hll = Cardunion(log2m=12)
        >>> new_hll.loads(zipped)

        # Union a list of hlls
        >>> list_of_hlls = [Cardunion(12)...]
        >>> union_hll = Cardunion(log2m=12)
        >>> union_hll.union(list_of_hlls)

        # Union a list of hlls' dumps
        >>> list_of_hll_dumps = [Cardunion(12).dump()...]
        >>> union_hll = Cardunion(log2m=12)
        >>> union_hll.bunion(list_of_hll_dumps)

        # Intersect a list of hlls
        >>> count, error, resolution = Cardunion.intersect(list_of_hlls)

        # Generate index and counter
        >>> i, counter = Cardunion.get_index_counter(hashed, log2m=12)
    """
    cdef uint8_t *counters
    cdef int32_t log2m, m

    def __cinit__(self, int32_t log2m=12):
        if not 4 <= log2m <= 16:
            raise ValueError("Invalid log2m value, should be in [4, 16].")
        self.log2m = log2m
        self.m = 1 << log2m
        self.counters = <uint8_t*>calloc(self.m, sizeof(uint8_t))
        if self.counters is NULL:
            raise MemoryError("Failed to initilize Cardunion, out of memory.")

    def __dealloc__(self):
        if self.counters is not NULL:
            free(self.counters)

    def bunion(self, phlls):
        """
        Union multiple Cardunion byte arrays, which could be generated by
        dumps. To union multiple Cardunion objects, use union function.
        """
        cdef uint8_t *buf, *data
        cdef uint16_t *key
        cdef uint8_t *value
        cdef int32_t n
        cdef int i

        for phll in phlls:
            buf = <uint8_t*><char*>phll
            n = (<int32_t*>buf)[0]
            data = buf + sizeof(int32_t)
            if n >> SPARSE_FLAG_BIT:
                n &= ~(1 << SPARSE_FLAG_BIT)
                if n > self.m:
                    raise ValueError("Invalid HLL byte arrays (SPARSE)")
                key, value = <uint16_t*>data, <uint8_t*>(data + n * sizeof(uint16_t))
                for i in range(n):
                    (self.counters + key[i])[0] = max((self.counters + key[i])[0], value[i])
            else:
                if n != self.m:
                    raise ValueError("Invalid HLL byte arrays.")
                for i in range(n):
                    (self.counters + i)[0] = max((self.counters + i)[0], (data + i)[0])

    cdef int _union(self, Cardunion hll):
        cdef int i

        if self.log2m != hll.log2m:
            return 1
        for i in range(self.m):
            (self.counters + i)[0] = max((self.counters + i)[0], (hll.counters + i)[0])
        return 0

    def union(self, hlls):
        """
        Union multiple Cardunion objects. To union multiple Cardunion
        byte arrays, use bunion function.
        """
        for hll in hlls:
            if self._union(hll):
                raise ValueError("Union hlls with different log2ms")

    def union_nonzero_counters(self, counters):
        """
        Union nonzero counters

        Argument: counters ,any iterable of tuples as (index, counter)
        """
        for i, counter in counters:
            self.update_counter(i, counter)

    @staticmethod
    def intersect(hlls, log2m=12):
        """
        Intersect multiple HyperLogLogs by using Inclusion-Exclusion-Rule.
        Harmonic error is used to estimate the error to favor the smaller set.

        Params:
            hlls. An iterable object, in which each element is a hll object
            log2m. An integer to init the HLL.
        Output:
            A tuple. (Cardinality, error and estimate resolution).
            Estimate resolution stands for the estimation quality of HLLs.
        """
        from itertools import combinations
        from math import sqrt

        def _intersect(hlls):
            union = Cardunion(log2m)
            union.union(hlls)
            count = union.count()
            # calculate the square of error = ( count*1.04/sqrt(m) )^2
            error = count * count * 1.04 * 1.04 / union.m
            return count, error

        count, error, square_error, n = 0, .0, .0, 0
        for i in range(len(hlls)):
            for hlls_ in combinations(hlls, i + 1):
                count_, error_ = _intersect(hlls_)
                if count_ == 0:
                    return 0L, 0L, 0L
                count += (-1) ** i * count_
                error += 1.0 / error_
                square_error += error_
                n += 1

        return count, long(round(sqrt(square_error))), long(round(sqrt((n / error))))

    cpdef update_counter(self, uint16_t index, uint8_t counter):
        """
        Update counter at the specified index, out of bound index error
        would be raised when the index is greater than current Cardunion.
        """
        if <int32_t>index > self.m:
            raise IndexError("Index is out of bound, max size allowed is %d" % self.m)
        if counter > (self.counters + index)[0]:
            (self.counters + index)[0] = counter

    def add(self, element):
        self.add_hashed(murmur3_x64_64(element, <long>HASH_SEED))

    cpdef add_hashed(self, uint64_t v):
        """Add a 64 bits hash code to current object, where the most significant
        log2m bits as index, rest of bits for counting leading zeros.
        """
        cdef uint64_t i
        cdef int32_t digest_len, bucket_index

        digest_len, bucket_index = HASH_LENGTH - self.log2m, self.log2m
        # left-most log2m bits for bucket index
        i = v >> digest_len
        # count leading zeros for following 64 - log2m bits
        leading_zeros = _count_leading_zeros(v << bucket_index, digest_len)
        self.update_counter(i, leading_zeros)

    cdef int _count_zero_counters(self):
        cdef int i
        cdef int nzeros = 0

        for i in range(self.m):
            if (self.counters + i)[0] == UINT_ZERO:
                nzeros += 1
        return nzeros

    @property
    def count_zeros(self):
        return self._count_zero_counters()

    @property
    def nonzero_counters(self):
        cdef int i
        cdef uint8_t counter

        for i in range(self.m):
            counter = (self.counters + i)[0]
            if counter != UINT_ZERO:
                yield int(i), int(counter)

    cdef int64_t _count(self):
        cdef int i
        cdef double estimate = .0
        cdef int nzeros = 0
        cdef uint8_t counter
        cdef double alphaMM

        for i in range(self.m):
            counter = (self.counters + i)[0]
            estimate += pow(2, -1 * counter)

        alphaMM = (0.7213 / (1 + 1.079 / self.m )) * self.m * self.m
        estimate = alphaMM / estimate
        if estimate <= 2.5 * self.m:
            nzeros = self._count_zero_counters()
            estimate = -1 * self.m * log((nzeros * 1.0) / self.m)
        else:
            estimate = 1 * estimate

        return <int64_t>round(estimate)

    def count(self):
        return long(self._count())

    @staticmethod
    def hash(element):
        return murmur3_x64_64(element, <long>HASH_SEED)

    @staticmethod
    def error_calc(count, m):
        from math import sqrt
        return long(count * (1.04 / sqrt(m)))

    @staticmethod
    def get_index_counter(uint64_t v, int32_t log2m):
        cdef uint64_t i
        cdef int32_t digest_len, bucket_index

        digest_len, bucket_index = HASH_LENGTH - log2m, log2m
        # left-most log2m bits for bucket index
        i = v >> digest_len
        # count leading zeros for following 64 - log2m bits
        leading_zeros = _count_leading_zeros(v << bucket_index, digest_len)
        return int(i), int(leading_zeros)

    def dumps(self):
        """
        Dump the vector of leading zeros counters as a byte array

        Note the byte array has two possible formats depends on what structure
        it's being used, i.e. sparse array or regular list.

        1. Sparse array,

        |  4 BYTES | KEY1, KEY2, ..., KEYN | VAL1, VAL2, ..., VALN |

        where in the first 4 bytes, the higher order byte is set to 1 to flag
        it as a sparse array. The lower 3 bytes as the length of sparse array.

        2. Regular list,

        |  4 BYTES | VAL1, VAL2, ..., VALN |

        where the first 4 bytes are set as the length of list.

        """
        import struct
        import cStringIO
        cdef int i
        cdef uint8_t c
        cdef int nzeros

        nzeros = self._count_zero_counters()
        if nzeros >= 3 * self.m / 4:
            n = int(self.m - nzeros) | 1 << SPARSE_FLAG_BIT
            s = struct.pack('i', n)
            k = cStringIO.StringIO()
            v = cStringIO.StringIO()
            for i in range(self.m):
                c = (self.counters + i)[0]
                if c > 0:
                    k.write(struct.pack("H", i))
                    v.write(struct.pack("B", c))
            s += k.getvalue()
            s += v.getvalue()
            k.close()
            v.close()
            return s
        else:
            o = cStringIO.StringIO()
            n = self.m
            o.write(struct.pack('i', n))
            o.write(self.counters[:self.m])
            s = o.getvalue()
            o.close()
            return s

    def loads(self, data):
        import struct
        cdef i
        cdef int zero = 0
        cdef uint8_t *p
        cdef int index
        cdef uint8_t counter

        n = struct.unpack('i', data[:SIZE_OF_SPARSE_FLAGS])[0]
        if n >> SPARSE_FLAG_BIT:
            n &= ~(1 << SPARSE_FLAG_BIT)
            if n > self.m:
                raise ValueError("Unknown HLL dumps")
            nkey_fmt = "%dH" % n
            nval_fmt = "%dB" % n
            key_size = struct.calcsize(nkey_fmt)
            value_size = struct.calcsize(nval_fmt)
            k = struct.unpack(nkey_fmt, data[SIZE_OF_SPARSE_FLAGS: SIZE_OF_SPARSE_FLAGS + key_size])
            v = struct.unpack(nval_fmt, data[SIZE_OF_SPARSE_FLAGS + key_size: SIZE_OF_SPARSE_FLAGS + key_size + value_size])
            memset(self.counters, zero, self.m * sizeof(uint8_t))
            for i in range(n):
                index = k[i]
                counter = v[i]
                if index >= self.m:
                    raise ValueError("Unknown HLL dumps")
                (self.counters + index)[0] = counter
        else:
            n = struct.unpack('i', data[:SIZE_OF_SPARSE_FLAGS])[0]
            if n != self.m:
                raise ValueError("Unknown HLL dumps")
            else:
                p = <uint8_t*>data
                memcpy(self.counters, p + sizeof(int), self.m * sizeof(uint8_t))
